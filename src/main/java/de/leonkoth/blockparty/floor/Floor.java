package de.leonkoth.blockparty.floor;

import de.leonkoth.blockparty.arena.Arena;
import de.leonkoth.blockparty.floor.generator.AreaGenerator;
import de.leonkoth.blockparty.floor.generator.FloorGenerator;
import de.leonkoth.blockparty.floor.generator.SingleBlockGenerator;
import de.leonkoth.blockparty.floor.generator.StripeGenerator;
import de.leonkoth.blockparty.player.PlayerInfo;
import de.leonkoth.blockparty.player.PlayerState;
import de.leonkoth.blockparty.schematic.FloorSchematic;
import de.leonkoth.blockparty.util.ParticlePlayer;
import de.leonkoth.blockparty.util.Util;
import lombok.Getter;
import lombok.Setter;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.block.Block;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

/**
 * Created by Leon on 14.03.2018.
 * Project Blockparty2
 * © 2016 - Leon Koth
 */
public class Floor {

    public static final int DEFAULT_ARENA_LENGTH = 42;
    public static final int DEFAULT_ARENA_WIDTH = 42;

    private Random random;
    private Arena arena;

    @Getter
    private Block currentBlock;

    @Setter
    @Getter
    private int length;

    @Setter
    @Getter
    private int width;

    @Setter
    @Getter
    private Location[] bounds;

    @Setter
    @Getter
    private List<FloorSchematic> floorSchematics;

    @Setter
    @Getter
    private List<String> floorNames;

    @Setter
    @Getter
    private List<FloorGenerator> generators = new ArrayList<>();

    public Floor(List<String> floorNames, Location[] bounds, Arena arena, int width, int length) {
        this.random = new Random();
        this.width = width;
        this.length = length;
        this.arena = arena;
        this.bounds = bounds;
        this.floorNames = floorNames;
        this.floorSchematics = new ArrayList<>();

        for (String name : floorNames) {
            FloorSchematic floorSchematic = new FloorSchematic(name, bounds);
            floorSchematic.loadFloorSchematic();
            floorSchematics.add(floorSchematic);
        }

        this.generators.add(new AreaGenerator());
        this.generators.add(new SingleBlockGenerator());
        this.generators.add(new StripeGenerator());
    }

    public static boolean create(Arena arena, Location[] bounds, int width, int length) {

        List<String> floorNames = new ArrayList<>();

        Floor floor;
        if (arena.getFloor() == null) {
            floor = new Floor(floorNames, bounds, arena, width, length);
        } else {
            floor = arena.getFloor();

            if (floor.getFloorNames() != null) {
                floorNames = floor.getFloorNames();
            }
        }

        floor.setDimensions(width, length);
        arena.setFloor(floor);

        arena.getArenaDataManager().getConfig().set("Configuration.Floor.EnabledFloors", floorNames);
        arena.getArenaDataManager().getConfig().set("Configuration.Floor.Width", arena.getFloor().getWidth());
        arena.getArenaDataManager().getConfig().set("Configuration.Floor.Length", arena.getFloor().getLength());

        arena.getArenaDataManager().saveLocation("Floor.A", bounds[0]);
        arena.getArenaDataManager().saveLocation("Floor.B", bounds[1]);

        try {
            arena.getArenaDataManager().save();
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }

        return true;
    }

    public static Floor getFromConfig(Arena arena) {
        Location a = arena.getArenaDataManager().getLocation("Floor.A");
        Location b = arena.getArenaDataManager().getLocation("Floor.B");
        Location[] bounds = new Location[]{a, b};
        List<String> enabledFloors = arena.getArenaDataManager().getConfig().getStringList("Configuration.Floor.EnabledFloors");
        int width = arena.getArenaDataManager().getConfig().getInt("Configuration.Floor.Width");
        int length = arena.getArenaDataManager().getConfig().getInt("Configuration.Floor.Length");

        return new Floor(enabledFloors, bounds, arena, width, length);
    }

    public void placeFloor() {
        if (arena.isUseSchematicFloors()) {

            if (this.arena.isUseAutoGeneratedFloors()) {
                int index = random.nextInt(floorSchematics.size() + generators.size());

                if (index < floorSchematics.size()) {
                    floorSchematics.get(index).placeFloor();
                } else {
                    generators.get(index - floorSchematics.size()).generateFloor(this);
                }
            } else {
                floorSchematics.get(random.nextInt(floorSchematics.size())).placeFloor();
            }

        } else {
            if (!this.arena.isUseAutoGeneratedFloors()) {
                Bukkit.getLogger().severe("[BlockParty] UseSchematicFloors and UseAutoGeneratedFloors disabled. Using auto generated floors now!");
            }

            generateFloor();
        }
    }

    public void setStartFloor() {
        if (this.arena.isUseSchematicFloors()) {

            if (floorSchematics.isEmpty()) {
                generateFloor();
                return;
            }

            for (FloorSchematic floorSchematic : this.getFloorSchematics()) {
                if (floorSchematic.getName().equalsIgnoreCase("start")) {
                    floorSchematic.placeFloor();
                    return;
                }
            }
            floorSchematics.get(random.nextInt(floorSchematics.size())).placeFloor();
        } else {
            generateFloor();
        }
    }

    public void setEndFloor() {
        if (this.arena.isUseSchematicFloors()) {

            if (floorSchematics.isEmpty()) {
                generateFloor();
                return;
            }

            for (FloorSchematic floorSchematic : this.getFloorSchematics()) {
                if (floorSchematic.getName().equalsIgnoreCase("end")) {
                    floorSchematic.placeFloor();
                    return;
                }
            }
            floorSchematics.get(random.nextInt(floorSchematics.size())).placeFloor();
        } else {
            generateFloor();
        }
    }

    private void generateFloor() {
        FloorGenerator generator = generators.get(random.nextInt(generators.size()));
        generator.generateFloor(this);
    }

    public void removeBlocks() {
        Byte data = currentBlock.getData();
        Material material = currentBlock.getType();

        for (Block block : getFloorBlocks()) {
            if (block.getData() != data || block.getType() != material) {
                block.setType(Material.AIR);
            }
        }
    }

    public List<Block> getFloorBlocks() {

        int minX = getMinX(bounds[0], bounds[1]);
        int maxX = getMaxX(bounds[0], bounds[1]);
        int minZ = getMinZ(bounds[0], bounds[1]);
        int maxZ = getMaxZ(bounds[0], bounds[1]);

        List<Block> blocks = new ArrayList<>();

        World world = bounds[0].getWorld();
        int y = bounds[0].getBlockY();
        for (int x = minX; x <= maxX; x++) {
            for (int z = minZ; z <= maxZ; z++) {
                blocks.add(world.getBlockAt(x, y, z));
            }
        }

        return blocks;
    }

    public void pickBlock() {
        currentBlock = getRandomBlock();
        updateInventories(currentBlock);
    }

    public void updateInventories(Block block) {

        ItemStack stack = new ItemStack(block.getType(), 1, block.getData());
        ItemMeta meta = stack.getItemMeta();
        meta.setDisplayName("§f§l§o" + Util.getName(block).split(":")[0]);
        stack.setItemMeta(meta);

        for (PlayerInfo playerInfo : this.arena.getPlayersInArena()) {
            if (playerInfo.getPlayerState() == PlayerState.INGAME) {
                Player player = playerInfo.asPlayer();

                player.getInventory().setItem(4, stack);
            }
        }
    }

    public void clearInventories() {
        for (PlayerInfo playerInfo : this.arena.getPlayersInArena()) {
            if (playerInfo.getPlayerState() == PlayerState.INGAME) {
                playerInfo.asPlayer().getInventory().clear();
            }
        }
    }

    private Block getRandomBlock() {
        Block block = getRandomLocation().getBlock();
        return block.getType() == Material.AIR ? getRandomBlock() : block;
    }

    public Location getRandomLocation() {
        World world = bounds[0].getWorld();
        int maxX = getMaxX(bounds[0], bounds[1]);
        int maxZ = getMaxZ(bounds[0], bounds[1]);
        int minX = getMinX(bounds[0], bounds[1]);
        int minZ = getMinZ(bounds[0], bounds[1]);
        int x = minX + random.nextInt(maxX - minX);
        int z = minZ + random.nextInt(maxZ - minZ);

        return new Location(world, x, bounds[0].getY(), z);
    }

    public void playParticles(int amount, int offsetY, int rangeY) {
        ParticlePlayer particlePlayer = arena.getParticlePlayer();

        for (int i = 0; i < amount; i++) {
            particlePlayer.play(pickRandomLocation(offsetY, rangeY), 1);
        }
    }

    public Location pickRandomLocation(int offsetY, int rangeY) {
        int minX = getMinX(bounds[0], bounds[1]);
        int maxX = getMaxX(bounds[0], bounds[1]);
        int minY = bounds[0].getBlockY() + offsetY;
        int maxY = minY + rangeY;
        int minZ = getMinZ(bounds[0], bounds[1]);
        int maxZ = getMaxZ(bounds[0], bounds[1]);

        int x = Util.getRandomValueInBetween(minX, maxX);
        int y = Util.getRandomValueInBetween(minY, maxY);
        int z = Util.getRandomValueInBetween(minZ, maxZ);

        return new Location(bounds[0].getWorld(), x, y, z);
    }

    public int getMaxX(Location a, Location b) {
        return Math.max(a.getBlockX(), b.getBlockX());
    }

    public int getMaxZ(Location a, Location b) {
        return Math.max(a.getBlockZ(), b.getBlockZ());
    }

    public int getMinX(Location a, Location b) {
        return Math.min(a.getBlockX(), b.getBlockX());
    }

    public int getMinZ(Location a, Location b) {
        return Math.min(a.getBlockZ(), b.getBlockZ());
    }

    public void setDimensions(int width, int length) {
        this.width = width;
        this.length = length;
    }

}
